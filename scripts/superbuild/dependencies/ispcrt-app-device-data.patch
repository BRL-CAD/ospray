commit 169a57d4f0307539db58f6a7615542e6e22a0a7b
Author: David E. DeMarle <david.demarle@intel.com>
Date:   Fri Aug 18 17:57:50 2023

    add-a-way-to-copy-app-device-data
    
    In OSPRay, we want to use ispcrt to copy application
    provided usm.device data to usm.shared data, which we
    can always work with. This change gives us a
    way to wrap the provided data so that ispcrt can copy
    it.

diff --git a/ispcrt/detail/gpu/GPUDevice.cpp b/ispcrt/detail/gpu/GPUDevice.cpp
index b564742f4..4bae855af 100644
--- a/ispcrt/detail/gpu/GPUDevice.cpp
+++ b/ispcrt/detail/gpu/GPUDevice.cpp
@@ -830,13 +830,19 @@ class ChunkedPool {
 struct MemoryView : public ispcrt::base::MemoryView {
     MemoryView(ze_context_handle_t context, ze_device_handle_t device, void *appMem, size_t numBytes,
                const ISPCRTNewMemoryViewFlags *flags, const GPUContext *ctxt)
-        : m_hostPtr(appMem), m_size(numBytes), m_requestedSize(numBytes), m_context(context), m_device(device),
+        : m_size(numBytes), m_requestedSize(numBytes), m_context(context), m_device(device),
           m_shared(flags->allocType == ISPCRT_ALLOC_TYPE_SHARED), m_smhint(flags->smHint), m_ctxtGPU(ctxt) {
         // We need context object to be alive until memoryview is alive
         if (m_ctxtGPU) {
             m_ctxtGPU->refInc();
         }
 
+        if (flags->smHint == ISPCRT_SM_APPLICATION_MANAGED_DEVICE) {
+            m_devicePtr = appMem;
+        } else {
+            m_hostPtr = appMem;
+        }
+
         // Use MemPool only when it is explicitly enabled with env var and memory hint is not device/host read/write
         m_useMemPool = get_bool_envvar(ISPCRT_MEM_POOL) && (m_smhint != ISPCRT_SM_HOST_DEVICE_READ_WRITE);
         if (m_ctxtGPU && m_useMemPool) {
@@ -847,7 +853,7 @@ struct MemoryView : public ispcrt::base::MemoryView {
     }
 
     ~MemoryView() {
-        if (m_devicePtr) {
+        if (m_devicePtr && m_smhint != ISPCRT_SM_APPLICATION_MANAGED_DEVICE) {
             if (m_shared && m_useMemPool && m_size <= m_memPool->maxChunkSize()) {
                 m_memPool->deallocate(m_devicePtr);
                 if (UNLIKELY(is_verbose)) {
diff --git a/ispcrt/ispcrt.h b/ispcrt/ispcrt.h
index 80e82094e..3fd134df0 100644
--- a/ispcrt/ispcrt.h
+++ b/ispcrt/ispcrt.h
@@ -142,6 +142,7 @@ typedef enum {
     ISPCRT_SM_HOST_DEVICE_READ_WRITE = 0,
     ISPCRT_SM_HOST_WRITE_DEVICE_READ,
     ISPCRT_SM_HOST_READ_DEVICE_WRITE,
+    ISPCRT_SM_APPLICATION_MANAGED_DEVICE,
     ISPCRT_SM_UNKNOWN,
 } ISPCRTSharedMemoryAllocationHint;
 
diff --git a/ispcrt/ispcrt.hpp b/ispcrt/ispcrt.hpp
index a8dcf8d0e..8b99b8a13 100644
--- a/ispcrt/ispcrt.hpp
+++ b/ispcrt/ispcrt.hpp
@@ -231,7 +231,12 @@ inline ISPCRTAllocationType Device::getMemoryAllocType(void *memBuffer) {
 
 enum class AllocType { Device, Shared };
 
-enum class SharedMemoryUsageHint { HostDeviceReadWrite, HostWriteDeviceRead, HostReadDeviceWrite };
+enum class SharedMemoryUsageHint {
+    HostDeviceReadWrite,
+    HostWriteDeviceRead,
+    HostReadDeviceWrite,
+    ApplicationManagedDevice
+};
 
 template <typename T, AllocType AT = AllocType::Device> class Array : public GenericObject<ISPCRTMemoryView> {
   public:
@@ -352,6 +357,9 @@ inline void set_shared_memory_view_flags(ISPCRTNewMemoryViewFlags *p, SharedMemo
     case SharedMemoryUsageHint::HostReadDeviceWrite:
         p->smHint = ISPCRT_SM_HOST_READ_DEVICE_WRITE;
         break;
+    case SharedMemoryUsageHint::ApplicationManagedDevice:
+        p->smHint = ISPCRT_SM_APPLICATION_MANAGED_DEVICE;
+        break;
     default:
         throw std::bad_alloc();
     }
