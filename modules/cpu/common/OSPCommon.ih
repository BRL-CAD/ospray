// Copyright 2009 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#ifdef OSPRAY_TARGET_SYCL
#include <CL/sycl.hpp>
#endif

#include "OSPConfig.h"

#ifdef OSPRAY_TARGET_SYCL
#include <cstdint>
#include "rkcommon/math/math.h"
#include "rkcommon/math/vec.h"

typedef uint64_t uint64;
typedef uint32_t uint32;
typedef uint16_t uint16;
typedef uint8_t uint8;

typedef int64_t int64;
typedef int32_t int32;
typedef int16_t int16;
typedef int8_t int8;
#else
#ifndef ISPC_UINT_IS_DEFINED
typedef unsigned int64 uint64;
typedef unsigned int32 uint32;
typedef unsigned int16 uint16;
typedef unsigned int8 uint8;
#endif
#endif

#ifdef OSPRAY_TARGET_SYCL
#include "rkcommon/platform.h"

#define LOG(x)

// Note: SYCL printf needs the type specifier, unlike ISPC. So instead of a
// macro we make a function that looks like the macro but overloads based on the
// type
#ifdef __SYCL_DEVICE_ONLY__
// rkcommon has its own macros for the host that we conflict with
#undef PRINT
#undef PRINT3

void PRINT(const int &x)
{
  cl::sycl::ext::oneapi::experimental::printf("#x = %d\n", x);
}

void PRINT(const uint32_t &x)
{
  cl::sycl::ext::oneapi::experimental::printf("#x = %u\n", x);
}

void PRINT(const float &x)
{
  cl::sycl::ext::oneapi::experimental::printf("#x = %f\n", x);
}

void PRINT3(const rkcommon::math::vec3i &x)
{
  cl::sycl::ext::oneapi::experimental::printf(
      "#x = (%d, %d, %d)\n", x.x, x.y, x.z);
}

void PRINT3(const rkcommon::math::vec3ui &x)
{
  cl::sycl::ext::oneapi::experimental::printf(
      "#x = (%u, %u, %u)\n", x.x, x.y, x.z);
}

void PRINT3(const rkcommon::math::vec3f &x)
{
  cl::sycl::ext::oneapi::experimental::printf(
      "#x = (%f, %f, %f)\n", x.x, x.y, x.z);
}

// SYCL is scalar, PRINTU = PRINT, PRINT3U = PRINT3
#define PRINTU(x) PRINT
#define PRINT3U(x) PRINT3

#define PRINT_STR(s) cl::sycl::ext::oneapi::experimental::printf(s);
#endif

#else

#define LOG(x)

#define PRINT(x) print(#x " = %\n", x)
#define PRINT3(x) print(#x " = (%, %, %)\n", get(x, 0), get(x, 1), get(x, 2))
// prints first unmasked element
#define PRINTU(x)                                                              \
  print(#x "[%] = %\n",                                                        \
      count_trailing_zeros(lanemask()),                                        \
      extract(x, count_trailing_zeros(lanemask())))
#define PRINT3U(x)                                                             \
  print(#x "[%] = (%, %, %)\n",                                                \
      count_trailing_zeros(lanemask()),                                        \
      extract(get(x, 0), count_trailing_zeros(lanemask())),                    \
      extract(get(x, 1), count_trailing_zeros(lanemask())),                    \
      extract(get(x, 2), count_trailing_zeros(lanemask())))

#define PRINT_STR(s) print(s);
#endif

OSPRAY_BEGIN_ISPC_NAMESPACE

/*! a C++-callable 'delete' of ISPC-side allocated memory of uniform objects */
export void delete_uniform(void *uniform uptr);

OSPRAY_END_ISPC_NAMESPACE

#ifndef OSPRAY_TARGET_SYCL
/*! 64-bit malloc. allows for alloc'ing memory larger than 64 bits */
extern "C" void *uniform malloc64(uniform uint64 size);
extern "C" void free64(void *uniform ptr);

/*! Thread Local Storage functions */
extern "C" void *uniform pushTLS(uniform uint64 size);
extern "C" void *uniform reallocTLS(void *uniform ptr, uniform uint64 size);
extern "C" void popTLS(void *uniform ptr);
#endif
